push swap alg
	while A !rot_sort
	if 1st > 2nd and 1st < last do swap // not sure
	else if 1st > 2nd and 1st > last  do send to B
											find spot -> smart rotate -> push 1st A to B
											so B is always reverse sorted
	else if 1st < 2nd && 1st > last

Check Sorts
- TIMSORT
	select run size
	while n < run_size
		reverse sort insert B
	then merge sort
vvaltone

10.1.
	need performance optimization (100 nbs by 200+ commands, 500nbs by 5000 commands)
	flags for checker
	implement sa && sb? (796. 806)
	fix everything for negative numbers (and protect from outside the range of int)
	RUN_SIZE into struct?
		- 500nb
			- 32 -> ~12k commands
			- 64 -> ~8.5k commands
	fix one number only arrays
	fix 5 numbers operations (must be under 12)
		e.g. 1 5 2 4 3 takes 17 commands
Script Test!
Random gen
printf '%s ' `seq 1 32 | sort -R`

arg=$(printf '%s ' `seq 1 32 | sort -R`)
echo arg

ARG="printf '%s ' `seq 1 501 | sort -R`"; ./ps_test $ARG | wc -l